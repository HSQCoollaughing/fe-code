### 前言
   最近在复习js基础，因为工作以后基本上没用过，天天都是拿起框架加油干，确实大部分都忘了。到了原型和原型链这一部分，觉得自己理解的比较模糊。又翻阅了《你不知道的javascript》、《javascript权威指南》还有阮一峰老师的[Javascript继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)，收获满满（感谢各位作者大佬）。所以整理成下面这篇文章，加深自己的印象，也希望对大家有所帮助。
   
   文章收录在作者代码库[fe-code](https://github.com/wuyawei/fe-code)，主要是个人学习的资料以及文章，觉得有帮助可以点个小星星，会持续更新。
   
   另外也希望大家可以支持一下我的开源作品[Vchat — 从头到脚，撸一个社交聊天系统（vue + node + mongodb）](https://juejin.im/post/5c0a00fb6fb9a049d4419d3a)，这是[源码仓库](https://github.com/wuyawei/Vchat)。感谢！
### Prototype
   在JavaScript中，可以通过关键字*new*调用构造函数来创建一个实例对象。
``` javascript
    function Person(name){
        this.name = name;
        this.say = function () {
            console.log(this.name);
        }
    }
    let lisi = new Person('lisi');
    let liwu = new Person('liwu');
    lisi.say() // lisi
    liwu.say() // liwu
    console.log(lisi.say === liwu.say); // false
    
```
   可以看出，lisi和liwu都有`say`这个方法，但是这两个方法并不是同一个。也就是说在创建对象的时候，每个实例对象都会有一套自己的属性和方法。很显然，这样造成了大量的资源浪费。
   
   这时候我们想，如果可以让实例对象引用同一个属性或方法就好了。所以JavaScript的作者引入了原型对象[Prototype]来解决这个问题。
``` javascript
    function Person(name){
        this.name = name;
    }
    Person.prototype.say = function () {
        console.log(this.name);
    }
    let lisi = new Person('lisi');
    let liwu = new Person('liwu');
    console.log(lisi.say === liwu.say); // true
    console.log(lisi.hasOwnProperty('say'), liwu.hasOwnProperty('say')); // false false
```
   这个时候可以看到，构造的新的实例对象都有`say`方法，但是`hasOwnProperty('say')`返回的结果却是false。这说明实例对象自身是没有`say`方法的，之所以可以使用`.say`的方式来调用，是因为在使用`.`语法的时候会调用对象自身的[get]方法。而[get]方法会优先查找自身的属性，没有找到则会通过`__proto__`来逐级查找上级的原型对象，直到js顶层的Object对象。所以此处可以说明实例对象会继承构造函数的原型对象上的属性和方法。
   
   但是正因为如此，我们需要注意的是：因为原型对象的属性和方法是会被所有实例对象继承的，所以使用的时候要慎重考虑该属性或方法是否适合放在原型对象上。比如Person有一个age属性：
``` javascript
    Person.prototype.age = 18;
    console.log(lisi.age, liwu.age); // 18 18
    Person.prototype.age = 20;
    console.log(lisi.age, liwu.age); // 20 20
```
   因为age属性是引用的Person的原型对象上的，所以原型对象上的属性值改了，所有的实例对象相应的属性值都会改动。这时候我们就不得不考虑，是否有必要将age属性放在原型对象了，毕竟每个人的年龄不一定一样。
   
   我们再来看下面这种情况：
``` javascript
    lisi.say = function() {
        console.log('oh nanana');
    };
    lisi.say(); // oh nanana
    liwu.say(); // liwu
    console.log(lisi.hasOwnProperty('say'), liwu.hasOwnProperty('say')); // true false
```
   这是为什么呢，其实和之前类似，是因为`.`语法在赋值的时候触发了对象的[set]方法，所以会给lisi自身加上一个say方法。而在调用方法时，最先找到自身的say方法调用，输出`oh nanana`。因为操作都是在lisi这个对象本身，所以对liwu没有影响。
### 何为原型链
### new
   var obj  = {};
   obj.__proto__ = Base.prototype;
   Base.call(obj);
### es6  class

### 原型和原型链
* 原型对象及prototype

  构造函数(只有函数对象才有)有一个prototype属性，指向实例对象的原型对象
* constructor

  原型对象有一个constructor属性，指向该原型对象对应的构造函数，所以每个constructor指向一个构造函数，构造函数又有原型对象，原型对象又有constructor，constructor又指向原型对象对应的构造函数...是一个无限引用的循环
* proto

  实例对象有__proto__ 属性，指向实例对象对应的原型对象
``` javascript
    function Foo() {}
    let foo = new foo();
    Foo.prototype.constructor === Foo;
    foo.__proto__ === Foo.prototype;
    Foo.prototype.__proto__ === Object.prototype; // 原型对象是对象, 它的构造函数是Object
    Object.prototype.__proto__ === null;
    
    // Foo是函数对象，它的__proto__指向 Function.prototype
    Function.prototype.__proto__ === Object.prototype
    
    // 实例对象没有prototype，自身也没有constructor，但是可以从原型链上继承constructor
    lisi.constructor === Person.prototype.constructor, Person.prototype.constructor === Person；
```
* 总结

【1】函数(Function也是函数)是new Function的结果，所以函数可以作为实例对象，其构造函数是Function()，原型对象是Function.prototype

【2】对象(函数也是对象，prototype也是对象)是new Object的结果，所以对象可以作为实例对象，其构造函数是Object()，原型对象是Object.prototype

【3】Object.prototype的原型对象是null