### 变量的解构赋值
* 数组
> 如果等号右边的值转为对象以后不具备 Iterator 接口， 或者本身就不具备 Iterator 接口，则会报错。

``` javascript
    let [a, b] = [1, 2];
    // a 1    b 2
    
    let [, b] = [1, 2];
    // b 2
    
    let [a, [b]] = [1, [2, 3]]; // 二维数组解构
    // a 1    b 2
```
* 对象
> 变量名必须与属性名一致才能取到值，如果不一致，需要补全。

``` javascript
    let { ocp, odp } = { ocp: 'aaa', odp: 'bbb' };
    // ocp 'aaa'    odp 'bbb'
    
    let { ocp: aa } = { ocp: 'a', odp: 'b' };
    // aa  'a'  只写变量其实是这种方式的简写
    
    // 对象也可以嵌套
    let obj = {
        person: {
            name: 'vchat',
            age: 1
        }
    };
    let { person, person: {name}} = obj;
    // person {name: "vchat", age: 1}
    // name  'vchat'
    
    let lisi = {};
    ({ pr: lisi.name } = {pr: 'lisi'});
    // lisi  {name: 'lisi'}
    // 这里要加圆括号 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。
    // 如单独运行 {id:0}; ， 并不会解析为一个对象，而是一个代码块，它的值为0，只是给0取了一个名字叫id，只有加上()才会正确解析。({id:0});
    
    // 解构常用内置方法
    let { log, sin, cos } = Math;
```
* 其他
> 等号右边如果不是数组，一般会先转换为对象

``` javascript
    1. 字符串被转换成了类数组的对象
    let [a, b, c] = '123456';
    // a '1'  b '2'  c '3'
    
    let {length : len} = 'hello';
    // len  5
    2. 数值和布尔值
    let {toString: n} = 123;
    let {toString: b} = true;
    // 数值和布尔值都有一个String方法
    // n,b  ƒ toString() { [native code] }
    3. 函数参数
    [[1, 2], [3, 4]].map(([a, b]) => a * b);
    // [2, 12]
```
* 默认值
> 解构赋值都可以指定默认值, ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。

``` javascript
    function f() {
        console.log('123');
        return '123';
    }
    
    let [x = f()] = [1];
    // f函数在解构的时候不会立即执行，只有在解构到的值为undefined时才会执行。
    
    let [x = 1, y = x] = [];
    // x=1; y=1  可以引用解构赋值内的已经声明的其他变量
    
    [[1, 2], []].map(([a = 1, b = 2]) => a * b);
    // [2, 2]
```