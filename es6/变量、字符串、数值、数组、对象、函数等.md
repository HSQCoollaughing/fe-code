### 变量的解构赋值
* 数组
> 如果等号右边的值转为对象以后不具备 Iterator 接口， 或者本身就不具备 Iterator 接口，则会报错。

``` javascript
    let [a, b] = [1, 2];
    // a 1    b 2
    
    let [, b] = [1, 2];
    // b 2
    
    let [a, [b]] = [1, [2, 3]]; // 二维数组解构
    // a 1    b 2
```
* 对象
> 变量名必须与属性名一致才能取到值，如果不一致，需要补全。

``` javascript
    let { ocp, odp } = { ocp: 'aaa', odp: 'bbb' };
    // ocp 'aaa'    odp 'bbb'
    
    let { ocp: aa } = { ocp: 'a', odp: 'b' };
    // aa  'a'  只写变量其实是这种方式的简写
    
    // 对象也可以嵌套
    let obj = {
        person: {
            name: 'vchat',
            age: 1
        }
    };
    let { person, person: {name}} = obj;
    // person {name: "vchat", age: 1}
    // name  'vchat'
    
    let lisi = {};
    ({ pr: lisi.name } = {pr: 'lisi'});
    // lisi  {name: 'lisi'}
    // 这里要加圆括号 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。
    // 如单独运行 {id:0}; ， 并不会解析为一个对象，而是一个代码块，它的值为0，只是给0取了一个名字叫id，只有加上()才会正确解析。({id:0});
    
    // 解构常用内置方法
    let { log, sin, cos } = Math;
```
* 其他
> 等号右边如果不是数组，一般会先转换为对象

``` javascript
    1. 字符串被转换成了类数组的对象
    let [a, b, c] = '123456';
    // a '1'  b '2'  c '3'
    
    let {length : len} = 'hello';
    // len  5
    
    2. 数值和布尔值
    let {toString: n} = 123;
    let {toString: b} = true;
    // 数值和布尔值都有一个String方法
    // n,b  ƒ toString() { [native code] }
    
    3. 函数参数
    [[1, 2], [3, 4]].map(([a, b]) => a * b);
    // [2, 12]
```
* 默认值
> 解构赋值都可以指定默认值, ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。

``` javascript
    function f() {
        console.log('123');
        return '123';
    }
    
    let [x = f()] = [1];
    // f函数在解构的时候不会立即执行，只有在解构到的值为undefined时才会执行。
    
    let [x = 1, y = x] = [];
    // x=1; y=1  可以引用解构赋值内的已经声明的其他变量
    
    [[1, 2], []].map(([a = 1, b = 2]) => a * b);
    // [2, 2]
```
### 扩展运算符
``` javascript
    console.log(...[1, 2, 3]) // 1,2,3
```
### rest运算符
### 数值的扩展
* Number.isFinite(), Number.isNaN() 
> 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。

``` javascript
    isFinite(2) // true
    isFinite("2") // true
    Number.isFinite(2) // true
    Number.isFinite("2") // false
    
    isNaN(NaN) // true
    isNaN("NaN") // true
    Number.isNaN(NaN) // true
    Number.isNaN("NaN") // false
```
* Math

``` javascript
    // Math.trunc()  去除一个数的小数部分，返回整数部分。
    Math.trunc(3.1) // 3
    Math.trunc(-3.8) // -3
    
    // Math.sign() 判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
    /*
        参数为正数，返回+1；
        参数为负数，返回-1；
        参数为 0，返回0；
        参数为-0，返回-0;
        其他值，返回NaN。 
    */
    Math.sign(-2) // -1
    Math.sign(2) // +1
    Math.sign(0) // +0
    Math.sign(-0) // -0
    Math.sign(NaN) // NaN
    
    // Math.cbrt() 计算一个数的立方根。
    Math.cbrt(8) // 2
    
    // 以下为es5方法
    Math.sqrt(4) // 2 计算一个数的平方根。
    Math.abs(-1) // 1 取绝对值
    Math.ceil(1.2) // 2 向上取整
    Math.ceil(1.2) // 2 向上取整
    Math.max(1, 2) // 2 返回 x 和 y 中的最大值。
    Math.min(1, 2) // 1 返回 x 和 y 中的最小值。
    Math.pow(2, 2) // 4 回 x 的 y 次幂。
    Math.random() // 返回 0 ~ 1 之间的随机数。
    Math.round(2.3) // 2 四舍五入
```
* 指数运算符 **
``` javascript
    2 ** 2 // 4
    2 ** 3 // 8
    // 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。
    let a = 1;
    a **= 2;
    // 等同于 a = a * a;
    
    let b = 2;
    b **= 3;
    // 等同于 b = b * b * b;
```
### 字符串扩展
* includes(), startsWith(), endsWith()。
``` javascript
    /*  1. includes() 表示是否找到了参数字符串。
        2. startsWith() 表示参数字符串是否在原字符串的头部
        3. endsWith() 表示参数字符串是否在原字符串的尾部
        4. 都返回布尔值，且支持第二个参数，作为开始查询的下标
    */
    let s = 'Hello world!';
    
    s.startsWith('Hello') // true
    s.endsWith('!') // true
    s.includes('o') // true
    
    s.startsWith('world', 6) // true
    s.endsWith('Hello', 5) // true
    s.includes('Hello', 6) // false
```
* repeat()
> 返回一个新的字符串，参数表示将原字符串重复n次

``` javascript
    'oh'.repeat(2) // 'ohoh'
    
    'na'.repeat(2.999) // 'nana' 小数会向下取整
    
    'na'.repeat(NaN) // ''  NaN 是 0
    
    // 参数是负数或者Infinity, 会报错。但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。true 等同1， false等同 0
```
* padStart()，padEnd()
> 字符串补全长度, padStart()用于头部补全，padEnd()用于尾部补全。

``` javascript
    '1'.padStart(10, '0'); // "0000000001"
    '12'.padStart(10, 'YYYY-MM-DD'); // "YYYY-MM-12"
    'oh'.padEnd(8, 'na') // 'ohnanana'
```
* 模版字符串
> 用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。

``` javascript
    let obj = {x: 1, y: 2};
    `${obj.x + obj.y}`;
    // "3"
    
    alert`123` // 标签模版
    // 等同于
    alert(123)
```

* es5 中常用字符串方法
``` javascript
    str.indexOf('a') //检索字符在指定字符串中第一次出现索引
    str.lastIndexOf('a') //检索字符在指定字符串中最后一次出现索引
    str.replace('/a/') // 替换与正则表达式匹配的子串。
    str.strike() // "<strike>Hello world!</strike>" 添加删除线
    
    // slice(start, end) 截取字符串指定首尾下标的某个部分（不包括结束下表的元素），并以新的字符串返回被截取的部分。
    /*
        start	截取片断的起始下标。如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。
        end	   截取片段的结束下标(不截取最后一个)。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。
    */
    'hello'.slice(0) // 'hello'
    'hello'.slice(-1) // 'o'
    'hello'.slice(0, -1) // 'hell'
    'hello'.slice(0, 2) // 'he'
    'hello'.slice(-2) // 'lo'
    
    // substr(start,length) 截取从 start 下标开始的指定长度的字符。
    /* start 如果是负数，则从最后一位开始计算位置*/
    'hello'.substr(0) // 'hello'
    'hello'.substr(-1) // 'o'
    'hello'.substr(0, 2) // 'he'
    // slice用下标计数，substr用指定长度，但是因为slice不截取end下标元素，所以实际上和按长度截取效果一样（前提是end为正数）。
    
    // substring(start, end) 截取字符串指定下标的某个部分，同slice。但是不支持负数。
    
    // split() 把一个字符串分割成字符串数组。
    'hello'.split('') // ["h", "e", "l", "l", "o"]
    'hello'.split() // ["hello"]
    'hello,world'.split(',') // ["hello", "world"]
    
```
### 数组的扩展

